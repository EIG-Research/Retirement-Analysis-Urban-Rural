TRUE ~ "Missing"
),
TIRAKEOVAL = ifelse(is.na(TIRAKEOVAL), 0,TIRAKEOVAL),
TTHR401VAL = ifelse(is.na(TTHR401VAL), 0, TTHR401VAL),
RETIREMENT_ACCT_VAL =
TIRAKEOVAL + # Value of IRA and Keogh accounts as of the last day of the reference period.
TTHR401VAL # Value of 401k, 403b, 503b, and Thrift Savings Plan accounts as of the last day of the reference period.
) %>%
select("SHHADID", "SPANEL", "SSUID", "SWAVE", "PNUM", "MONTHCODE", "WPFINWGT",
"TAGE", "EDUCATION", "SEX", "RACE", "METRO_STATUS",
"EMPLOYMENT_TYPE", "CLASS_OF_WORKER",
"TPTOTINC",
"ANY_RETIREMENT_ACCESS",
"PARTICIPATING",
"MATCHING", "MONTHCODE", "TJB1_JOBHRS1", "TOTYEARINC",
"IN_AGE_RANGE","FULL_PART_TIME", "TVAL_RET",
"TJB1_IND",
"RETIREMENT_ACCT_VAL",
"EJB1_EMPSIZE",
"TST_INTV", "EMPLOYER_SIZE", "EEDUC", "EJB1_EMPSIZE")
industry_codes = read_excel(paste(
data_path, "Census Industry Codes",
"2017-industry-code-list-with-crosswalk .xlsx",
sep="/"),
sheet = "2017 Census Industry Code List",
skip=3) %>%
rename(INDUSTRY_BROAD = ...1,
INDUSTRY_DETAILED = `Industry 2017 Description`) %>%
select(-c(...3, contains("NAICS"))) %>%
# fill broad industry types downward
fill(INDUSTRY_BROAD, .direction = "down") %>%
# convert codes to numeric. dropps the 2nd order industry categories.
# generates NAs.
mutate(`2017 Census Code` = as.numeric(`2017 Census Code`)) %>%
na.omit() %>% distinct()
# merge in industry codes.
sipp_2023 = sipp_2023 %>%
left_join(industry_codes,
by = c("TJB1_IND" = "2017 Census Code"),
relationship = "many-to-one")
sipp_2023 = sipp_2023 %>%
filter(IN_AGE_RANGE == "yes") %>%
filter(EMPLOYMENT_TYPE == "Employer") %>%
filter(CLASS_OF_WORKER ==  "Employee of a private, for-profit company" |
CLASS_OF_WORKER == "Employee of a private, not-for-profit company") %>%
filter(FULL_PART_TIME == "full time") %>%
filter(ANY_RETIREMENT_ACCESS != "Missing" &
MATCHING != "Missing" &
PARTICIPATING != "Missing") %>%
filter(TPTOTINC >0)   %>% # earning an income
# extract variables for export
select("SHHADID", "SPANEL", "SSUID", "SWAVE", "PNUM", "MONTHCODE", "WPFINWGT",
"TAGE", "EDUCATION", "SEX", "RACE", "METRO_STATUS",
"EMPLOYMENT_TYPE", "CLASS_OF_WORKER",
"TPTOTINC",
"ANY_RETIREMENT_ACCESS",
"PARTICIPATING",
"MATCHING", "MONTHCODE", "TJB1_JOBHRS1", "TOTYEARINC",
"TVAL_RET",
"TJB1_IND",
"RETIREMENT_ACCT_VAL",
"EJB1_EMPSIZE",
"INDUSTRY_BROAD",
"INDUSTRY_DETAILED",
"TST_INTV", "EMPLOYER_SIZE", "EEDUC", "EJB1_EMPSIZE")
# save file
setwd(output_path)
save(sipp_2023, file = "SIPP_2023_WRANGLED.RData")
# remove dependencies
rm(list = ls())
# load packages
library(dplyr)
library(tidyr)
library(readxl)
library(ranger)
library(ggplot2)
library(tibble)
# set user path
project_directories <- list(
"sarah" = "/Users/sarah/Documents/GitHub/Retirement-Analysis-Urban-Rural",
"jiaxinhe" = "/Users/jiaxinhe/Documents/projects/Retirement-Analysis-Urban-Rural"
)
current_user <- Sys.info()[["user"]]
if (!current_user %in% names(project_directories)) {
stop("Root folder for current user is not defined.")
}
# set project paths
project_path = project_directories[[current_user]]
data_path = file.path(project_path, "Data")
sipp_path = file.path(data_path, "SIPP/2023")
output_path = file.path(project_path, "Output")
# set working directory for 2023 SIPP
setwd(output_path)
# read in cleaned SIPP data
load("SIPP_2023_WRANGLED.RData")
names(sipp_2023)
sipp_2023_subset = sipp_2023 %>%
rename(age = TAGE,
`account_value` = RETIREMENT_ACCT_VAL,
income = TPTOTINC) %>%
# factor conversions
mutate(access = case_when(
ANY_RETIREMENT_ACCESS == "Yes" ~ 1,
ANY_RETIREMENT_ACCESS == "No" ~ 0,
ANY_RETIREMENT_ACCESS == "Missing" ~ NA
),
matching = case_when(
MATCHING == "Yes" ~ 1,
MATCHING == "No" ~ 0,
MATCHING == "Missing" ~ NA
),
participates = case_when(
PARTICIPATING == "Yes" ~ 1,
PARTICIPATING == "No" ~ 0,
PARTICIPATING == "Missing" ~ NA
),
# generate categoricals.
# idnustry is not ordered
# education and employer size are
education = factor(EEDUC, ordered = TRUE),
industry = factor(INDUSTRY_BROAD, ordered = FALSE),
employer_size = factor(EJB1_EMPSIZE, ordered = TRUE),
`metro_status` = as.numeric(factor(METRO_STATUS))
)
View(sipp_2023_subset)
sipp_2023_subset = sipp_2023 %>%
rename(age = TAGE,
`account_value` = RETIREMENT_ACCT_VAL,
income = TPTOTINC) %>%
# factor conversions
mutate(access = case_when(
ANY_RETIREMENT_ACCESS == "Yes" ~ 1,
ANY_RETIREMENT_ACCESS == "No" ~ 0,
ANY_RETIREMENT_ACCESS == "Missing" ~ NA
),
matching = case_when(
MATCHING == "Yes" ~ 1,
MATCHING == "No" ~ 0,
MATCHING == "Missing" ~ NA
),
participates = case_when(
PARTICIPATING == "Yes" ~ 1,
PARTICIPATING == "No" ~ 0,
PARTICIPATING == "Missing" ~ NA
),
# generate categoricals.
# idnustry is not ordered
# education and employer size are
education = factor(EEDUC, ordered = TRUE),
industry = factor(INDUSTRY_BROAD, ordered = FALSE),
employer_size = factor(EJB1_EMPSIZE, ordered = TRUE),
metro_status = case_when(
METRO_STATUS == "Metropolitan area" ~ 1,
METRO_STATUS == "Non-metropolitan area" ~ 0,
TRUE ~ NA
),
metro_status = factor(METRO_STATUS, ordered = TRUE))
sipp_2023_subset = sipp_2023 %>%
rename(age = TAGE,
`account_value` = RETIREMENT_ACCT_VAL,
income = TPTOTINC) %>%
# factor conversions
mutate(access = case_when(
ANY_RETIREMENT_ACCESS == "Yes" ~ 1,
ANY_RETIREMENT_ACCESS == "No" ~ 0,
ANY_RETIREMENT_ACCESS == "Missing" ~ NA
),
matching = case_when(
MATCHING == "Yes" ~ 1,
MATCHING == "No" ~ 0,
MATCHING == "Missing" ~ NA
),
participates = case_when(
PARTICIPATING == "Yes" ~ 1,
PARTICIPATING == "No" ~ 0,
PARTICIPATING == "Missing" ~ NA
),
# generate categoricals.
# idnustry is not ordered
# education and employer size are
education = factor(EEDUC, ordered = TRUE),
industry = factor(INDUSTRY_BROAD, ordered = FALSE),
employer_size = factor(EJB1_EMPSIZE, ordered = TRUE),
metro_status = case_when(
METRO_STATUS == "Metropolitan area" ~ 1,
METRO_STATUS == "Non-metropolitan area" ~ 0,
TRUE ~ NA
),
metro_status = factor(metro_status, ordered = TRUE))
sipp_2023_subset = sipp_2023 %>%
rename(age = TAGE,
`account_value` = RETIREMENT_ACCT_VAL,
income = TPTOTINC) %>%
# factor conversions
mutate(access = case_when(
ANY_RETIREMENT_ACCESS == "Yes" ~ 1,
ANY_RETIREMENT_ACCESS == "No" ~ 0,
ANY_RETIREMENT_ACCESS == "Missing" ~ NA
),
matching = case_when(
MATCHING == "Yes" ~ 1,
MATCHING == "No" ~ 0,
MATCHING == "Missing" ~ NA
),
participates = case_when(
PARTICIPATING == "Yes" ~ 1,
PARTICIPATING == "No" ~ 0,
PARTICIPATING == "Missing" ~ NA
),
# generate categoricals.
# idnustry is not ordered
# education and employer size are
education = factor(EEDUC, ordered = TRUE),
industry = factor(INDUSTRY_BROAD, ordered = FALSE),
employer_size = factor(EJB1_EMPSIZE, ordered = TRUE),
metro_status = factor(case_when(
METRO_STATUS == "Metropolitan area" ~ 1,
METRO_STATUS == "Non-metropolitan area" ~ 0,
TRUE ~ NA
), ordered = TRUE)) %>%
select(WPFINWGT,
access,
matching,
participates,
`account_value`,
age,
education,
income,
industry,
`metro_status`,
`employer_size`,
METRO_STATUS,
EMPLOYER_SIZE,
EDUCATION,
INDUSTRY_BROAD
) %>%
na.omit()
# split train & test data
# 80 / 20
train_index <- sample(1:nrow(sipp_2023_subset), 0.8 * nrow(sipp_2023_subset))
train_data <- sipp_2023_subset[train_index, ]
test_data <- sipp_2023_subset[-train_index, ]
sipp_2023_subset = sipp_2023 %>%
rename(age = TAGE,
`account_value` = RETIREMENT_ACCT_VAL,
income = TPTOTINC) %>%
# factor conversions
mutate(access = case_when(
ANY_RETIREMENT_ACCESS == "Yes" ~ 1,
ANY_RETIREMENT_ACCESS == "No" ~ 0,
ANY_RETIREMENT_ACCESS == "Missing" ~ NA
),
matching = case_when(
MATCHING == "Yes" ~ 1,
MATCHING == "No" ~ 0,
MATCHING == "Missing" ~ NA
),
participates = case_when(
PARTICIPATING == "Yes" ~ 1,
PARTICIPATING == "No" ~ 0,
PARTICIPATING == "Missing" ~ NA
),
# generate categoricals.
# idnustry is not ordered
# education and employer size are
education = factor(EEDUC, ordered = TRUE),
industry = factor(INDUSTRY_BROAD, ordered = FALSE),
employer_size = factor(EJB1_EMPSIZE, ordered = TRUE),
metro_status = factor(case_when(
METRO_STATUS == "Metropolitan area" ~ 1,
METRO_STATUS == "Non-metropolitan area" ~ 0,
TRUE ~ NA
), ordered = TRUE)) %>%
select(WPFINWGT,
access,
matching,
participates,
`account_value`,
age,
education,
income,
industry,
`metro_status`,
`employer_size`
) %>%
na.omit()
# split train & test data
# 80 / 20
train_index <- sample(1:nrow(sipp_2023_subset), 0.8 * nrow(sipp_2023_subset))
train_data <- sipp_2023_subset[train_index, ]
test_data <- sipp_2023_subset[-train_index, ]
bootstrap_classification <-  function(model_formula, model_data, model_weights, num_repeats = 100, num_trees = 500) {
results <- replicate(num_repeats, {
rf <- ranger(model_formula, data = model_data,
num.trees = num_trees,
case.weights = model_weights,
classification = TRUE,
write.forest = TRUE,
importance = 'permutation',
respect.unordered.factors = TRUE,
scale.permutation.importance = TRUE)
rf$variable.importance
}, simplify = "array")
# Compute mean and standard deviation across repeats
importance_summary <- apply(results, 1, function(x) c(mean = mean(x), sd = sd(x)))
importance_df <- data.frame(importance_summary)
importance_df =
rownames_to_column(importance_df, var = "stat") %>%
pivot_longer(cols = names(importance_df),
names_to = "variable") %>%
pivot_wider(names_from = "stat",
values_from = "value")
return(importance_df)
}
bootstrap_regression <-  function(model_formula, model_data, model_weights, num_repeats = 100, num_trees = 500) {
results <- replicate(num_repeats, {
rf <- ranger(model_formula, data = model_data,
num.trees = num_trees,
case.weights = model_weights,
classification = FALSE,
write.forest = TRUE,
importance = 'permutation',
respect.unordered.factors = TRUE,
scale.permutation.importance = TRUE)
rf$variable.importance
}, simplify = "array")
# Compute mean and standard deviation across repeats
importance_summary <- apply(results, 1, function(x) c(mean = mean(x), sd = sd(x)))
importance_df <- data.frame(importance_summary)
importance_df =
rownames_to_column(importance_df, var = "stat") %>%
pivot_longer(cols = names(importance_df),
names_to = "variable") %>%
pivot_wider(names_from = "stat",
values_from = "value")
return(importance_df)
}
set.seed(42)  # For reproducibility
access_results <- bootstrap_classification(
model_formula =  access ~ age + industry + income + education + metro_status + employer_size,
model_data = train_data,
model_weights = train_data$WPFINWGT)
participation_results = bootstrap_classification(
model_formula =  participates ~ age + industry + income + education + metro_status + employer_size,
model_data = train_data,
model_weights = train_data$WPFINWGT)
account_value_results = bootstrap_regression(
model_formula =  account_value ~ age + industry + income + education + metro_status + employer_size,
model_data = train_data,
model_weights = train_data$WPFINWGT)
matching_results <- bootstrap_classification(
model_formula =  matching ~ age + industry + income + education + metro_status + employer_size,
model_data = train_data,
model_weights = train_data$WPFINWGT)
account_value_results
# standardize coefficients - using proportions
access_results = access_results %>%
mutate(importance_scaled = mean/sum(mean)) %>%
rename(importance = mean)
matching_results = matching_results %>%
mutate(importance_scaled = mean/sum(mean)) %>%
rename(importance = mean)
participation_results = participation_results %>%
mutate(importance_scaled = mean/sum(mean)) %>%
rename(importance = mean)
account_value_results = account_value_results %>%
mutate(importance_scaled = mean/sum(mean)) %>%
rename(importance = mean)
# export for display.
setwd(output_path)
write.csv(access_results, "rf_access.csv")
write.csv(matching_results, "rf_matching.csv")
write.csv(participation_results, "rf_participation.csv")
write.csv(account_value_results, "rf_account_value.csv")
# combine results for datawrapper display.
access_datawr = access_results %>% select(variable, importance_scaled) %>%
mutate(category = "access to an employer based retirement plan")
matching_datawr = matching_results %>% select(variable, importance_scaled) %>%
mutate(category = "employer provides matching benefits")
participation_datawr = participation_results %>% select(variable, importance_scaled) %>%
mutate(category = "participates in employer baesd retirement plan")
account_datawr = account_value_results %>% select(variable, importance_scaled) %>%
mutate(category = "retirement account value")
# combine
datawrapper = bind_rows(access_datawr,
matching_datawr,
participation_datawr,
account_datawr)
View(datawrapper)
View(access_results)
# standardize coefficients - using proportions
access_results = access_results %>%
mutate(importance_scaled = 100*mean/sum(mean)) %>%
rename(importance = mean)
# Compute mean and standard deviation across repeats
importance_summary <- apply(results, 1, function(x) c(importance = mean(x), sd = sd(x)))
bootstrap_classification <-  function(model_formula, model_data, model_weights, num_repeats = 100, num_trees = 500) {
results <- replicate(num_repeats, {
rf <- ranger(model_formula, data = model_data,
num.trees = num_trees,
case.weights = model_weights,
classification = TRUE,
write.forest = TRUE,
importance = 'permutation',
respect.unordered.factors = TRUE,
scale.permutation.importance = TRUE)
rf$variable.importance
}, simplify = "array")
# Compute mean and standard deviation across repeats
importance_summary <- apply(results, 1, function(x) c(importance = mean(x), sd = sd(x)))
importance_df <- data.frame(importance_summary)
importance_df =
rownames_to_column(importance_df, var = "stat") %>%
pivot_longer(cols = names(importance_df),
names_to = "variable") %>%
pivot_wider(names_from = "stat",
values_from = "value")
return(importance_df)
}
bootstrap_regression <-  function(model_formula, model_data, model_weights, num_repeats = 100, num_trees = 500) {
results <- replicate(num_repeats, {
rf <- ranger(model_formula, data = model_data,
num.trees = num_trees,
case.weights = model_weights,
classification = FALSE,
write.forest = TRUE,
importance = 'permutation',
respect.unordered.factors = TRUE,
scale.permutation.importance = TRUE)
rf$variable.importance
}, simplify = "array")
# Compute mean and standard deviation across repeats
importance_summary <- apply(results, 1, function(x) c(importance = mean(x), sd = sd(x)))
importance_df <- data.frame(importance_summary)
importance_df =
rownames_to_column(importance_df, var = "stat") %>%
pivot_longer(cols = names(importance_df),
names_to = "variable") %>%
pivot_wider(names_from = "stat",
values_from = "value")
return(importance_df)
}
set.seed(42)  # For reproducibility
access_results <- bootstrap_classification(
model_formula =  access ~ age + industry + income + education + metro_status + employer_size,
model_data = train_data,
model_weights = train_data$WPFINWGT)
matching_results <- bootstrap_classification(
model_formula =  matching ~ age + industry + income + education + metro_status + employer_size,
model_data = train_data,
model_weights = train_data$WPFINWGT)
participation_results = bootstrap_classification(
model_formula =  participates ~ age + industry + income + education + metro_status + employer_size,
model_data = train_data,
model_weights = train_data$WPFINWGT)
account_value_results = bootstrap_regression(
model_formula =  account_value ~ age + industry + income + education + metro_status + employer_size,
model_data = train_data,
model_weights = train_data$WPFINWGT)
account_value_results
access_results = access_results %>%
mutate(importance_scaled = 100*importance/sum(importance))
matching_results = matching_results %>%
mutate(importance_scaled = 100*importance/sum(importance))
participation_results = participation_results %>%
mutate(importance_scaled = 100*importance/sum(importance))
account_value_results = account_value_results %>%
mutate(importance_scaled = 100*importance/sum(importance))
setwd(output_path)
write.csv(access_results, "rf_access.csv")
write.csv(matching_results, "rf_matching.csv")
write.csv(participation_results, "rf_participation.csv")
write.csv(account_value_results, "rf_account_value.csv")
# combine results for datawrapper display.
access_datawr = access_results %>% select(variable, importance_scaled) %>%
mutate(category = "Access to an employer based retirement plan")
matching_datawr = matching_results %>% select(variable, importance_scaled) %>%
mutate(category = "Employer provides matching benefits")
participation_datawr = participation_results %>% select(variable, importance_scaled) %>%
mutate(category = "Participates in employer baesd retirement plan")
account_datawr = account_value_results %>% select(variable, importance_scaled) %>%
mutate(category = "Retirement account value")
# combine
datawrapper = bind_rows(access_datawr,
participation_datawr,
access_datawr,
account_datawr)
View(datawrapper)
write.csv(datawrapper, "rf_datawrapper_friendly.csv")
write.csv(datawrapper, "rf_datawrapper_friendly.csv")
# combine
datawrapper = bind_rows(access_datawr,
participation_datawr,
matching_datawr,
account_datawr)
write.csv(datawrapper, "rf_datawrapper_friendly.csv")
# combine
datawrapper = bind_rows(access_datawr,
participation_datawr,
matching_datawr,
account_datawr) %>%
mutate(variable = case_when(
variable == "employer_size" ~ "employer size",
variable == "metro_status" ~ "metro status",
TRUE ~ variable
))
write.csv(datawrapper, "rf_datawrapper_friendly.csv")
View(access_datawr)
View(access_results)
load("SCF_2022_WRANGLED.RData")
unique(scf_2022$INDUSTRY)
unique(scf_2022$INDUSTRY)
