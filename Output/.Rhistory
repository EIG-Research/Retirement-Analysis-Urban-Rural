TRUE ~ "Missing"
),
SEX = case_when(
ESEX == 1 ~ "Male",
ESEX == 2 ~ "Female",
TRUE ~ "Missing"
),
RACE = case_when(
ERACE == 1 & EORIGIN ==2 ~ "Non-Hispanic White",
ERACE == 2 & EORIGIN ==2 ~ "Non-Hispanic Black",
ERACE == 3 & EORIGIN ==2 ~ "Asian",
EORIGIN == 1 ~ "Hispanic",
ERACE == 4 & EORIGIN == 2 ~ "Mixed/Other",
TRUE ~ "Missing"
),
EMPLOYMENT_TYPE = case_when(
EJB1_JBORSE == 1 ~ "Employer",
EJB1_JBORSE == 2 ~ "Self-employed (owns a business)",
EJB1_JBORSE == 3 ~ "Other work arrangement",
TRUE ~ "Missing"
),
CLASS_OF_WORKER = case_when(
EJB1_CLWRK == 1 ~ "Federal government employee",
EJB1_CLWRK == 2 ~ "Active duty military",
EJB1_CLWRK == 3 ~ "State government employee",
EJB1_CLWRK == 4 ~ "Local government employee",
EJB1_CLWRK == 5 ~ "Employee of a private, for-profit company",
EJB1_CLWRK == 6 ~ "Employee of a private, not-for-profit company",
EJB1_CLWRK == 7 ~ "Self-employed in own incorporated business",
EJB1_CLWRK == 8 ~ "Self-employed in own not incorporated business",
TRUE ~ "Missing"
),
TOTYEARINC = TPTOTINC*12, # monthly income
METRO_STATUS = case_when(
TMETRO_INTV == 1 ~ "Metropolitan area",
TMETRO_INTV == 2 ~ "Nonmetropolitan area",
TMETRO_INTV == 3 ~ "Not identified",
TRUE ~ NA
),
FULL_PART_TIME = case_when( # Define full time workers as those working at least 35 hours
TJB1_JOBHRS1 >=35 ~ "full time",
TJB1_JOBHRS1 >0 & TJB1_JOBHRS1< 35 ~ "part time",
TRUE ~ NA
),
IN_AGE_RANGE = case_when(     # 18-65 ages
TAGE >= 18 & TAGE <= 65 ~ "yes",
TAGE >= 0 & TAGE <= 17 ~ "no",
TAGE >= 66 & TAGE <= 100 ~ "no",
TRUE ~ NA
),
#######################
# retirement variables
ANY_RETIREMENT_ACCESS = case_when(
EMJOB_401 == 1 ~ "Yes", # Any 401k, 403b, 503b, or Thrift Savings Plan account(s) provided through main employer or business during the reference period.
EMJOB_IRA == 1 ~ "Yes", # Any IRA or Keogh account(s) provided through main employer or business during the reference period.
EMJOB_PEN == 1 ~ "Yes", # Any defined-benefit or cash balance plan(s) provided through main employer or business during the reference period.
EMJOB_401 == 2 ~ "No",
EMJOB_IRA == 2 ~ "No",
EMJOB_PEN == 2 ~ "No",
EOWN_THR401  == 2 ~ "No",
EOWN_IRAKEO  == 2 ~ "No",
EOWN_PENSION == 2 ~ "No",
TRUE ~ "Missing"
),
PARTICIPATING = case_when(
ESCNTYN_401 == 1 ~ "Yes", # During the reference period, respondent contributed to the 401k, 403b, 503b, or Thrift Savings Plan account(s) provided through their main employer or business.
EECNTYN_401 == 1 ~ "Yes", # if they report having employer matching then we term them as participating
ESCNTYN_PEN == 1 ~ "Yes", # During the reference period, respondent contributed to the defined-benefit or cash balance plan(s) provided through their main employer or business.
ESCNTYN_IRA == 1 ~ "Yes", # During the reference period, respondent contributed to the IRA or Keogh account(s) provided through their main employer or business.
ESCNTYN_401 == 2 ~ "No",
ESCNTYN_PEN == 2 ~ "No",
ESCNTYN_IRA == 2 ~ "No",
EOWN_THR401  == 2 ~ "No",
EOWN_IRAKEO  == 2 ~ "No",
EOWN_PENSION == 2 ~ "No",
TRUE ~ "Missing"
),
MATCHING = case_when(
EECNTYN_401 == 1 ~ "Yes", # Main employer or business contributed to respondent's 401k, 403b, 503b, or Thrift Savings Plan account(s) during the reference period.
EECNTYN_IRA == 1  ~ "Yes", # Main employer or business contributed to respondent's IRA or Keogh account(s) during the reference period.
EECNTYN_401 == 2 ~ "No",
EECNTYN_IRA == 2 ~ "No",
EOWN_THR401  == 2 ~ "No",
EOWN_IRAKEO  == 2 ~ "No",
EOWN_PENSION == 2 ~ "No",
# is.na(EECNTYN_401) ~ "No",
TRUE ~ "Missing"
),
RETIREMENT_ACCT_VAL =
TIRAKEOVAL + # Value of IRA and Keogh accounts as of the last day of the reference period.
TTHR401VAL # Value of 401k, 403b, 503b, and Thrift Savings Plan accounts as of the last day of the reference period.
) %>%
select("SHHADID", "SPANEL", "SSUID", "SWAVE", "PNUM", "MONTHCODE", "WPFINWGT",
"TAGE", "EDUCATION", "SEX", "RACE", "METRO_STATUS",
"EMPLOYMENT_TYPE", "CLASS_OF_WORKER",
"TPTOTINC",
"ANY_RETIREMENT_ACCESS",
"PARTICIPATING",
"MATCHING", "MONTHCODE", "TJB1_JOBHRS1", "TOTYEARINC",
"IN_AGE_RANGE","FULL_PART_TIME", "TVAL_RET",
"TJB1_IND",
"RETIREMENT_ACCT_VAL",
"TST_INTV")
industry_codes = read_excel(paste(
data_path, "Census Industry Codes",
"2017-industry-code-list-with-crosswalk .xlsx",
sep="/"),
sheet = "2017 Census Industry Code List",
skip=3) %>%
rename(INDUSTRY_BROAD = ...1,
INDUSTRY_DETAILED = `Industry 2017 Description`) %>%
select(-c(...3, contains("NAICS"))) %>%
# fill broad industry types downward
fill(INDUSTRY_BROAD, .direction = "down") %>%
# convert codes to numeric. dropps the 2nd order industry categories.
# generates NAs.
mutate(`2017 Census Code` = as.numeric(`2017 Census Code`)) %>%
na.omit() %>% distinct()
# merge in industry codes.
sipp_2023 = sipp_2023 %>%
left_join(industry_codes,
by = c("TJB1_IND" = "2017 Census Code"),
relationship = "many-to-one")
sipp_2023 = sipp_2023 %>%
filter(IN_AGE_RANGE == "yes") %>%
filter(EMPLOYMENT_TYPE == "Employer") %>%
filter(CLASS_OF_WORKER ==  "Employee of a private, for-profit company" |
CLASS_OF_WORKER == "Employee of a private, not-for-profit company") %>%
filter(FULL_PART_TIME == "full time") %>%
filter(TPTOTINC >0)   %>% # earning an income
# extract variables for export
select("SHHADID", "SPANEL", "SSUID", "SWAVE", "PNUM", "MONTHCODE", "WPFINWGT",
"TAGE", "EDUCATION", "SEX", "RACE", "METRO_STATUS",
"EMPLOYMENT_TYPE", "CLASS_OF_WORKER",
"TPTOTINC",
"ANY_RETIREMENT_ACCESS",
"PARTICIPATING",
"MATCHING", "MONTHCODE", "TJB1_JOBHRS1", "TOTYEARINC",
"TVAL_RET",
"TJB1_IND",
"RETIREMENT_ACCT_VAL",
"INDUSTRY_BROAD",
"INDUSTRY_DETAILED"
"TST_INTV")
sipp_2023 = sipp_2023 %>%
filter(IN_AGE_RANGE == "yes") %>%
filter(EMPLOYMENT_TYPE == "Employer") %>%
filter(CLASS_OF_WORKER ==  "Employee of a private, for-profit company" |
CLASS_OF_WORKER == "Employee of a private, not-for-profit company") %>%
filter(FULL_PART_TIME == "full time") %>%
filter(TPTOTINC >0)   %>% # earning an income
# extract variables for export
select("SHHADID", "SPANEL", "SSUID", "SWAVE", "PNUM", "MONTHCODE", "WPFINWGT",
"TAGE", "EDUCATION", "SEX", "RACE", "METRO_STATUS",
"EMPLOYMENT_TYPE", "CLASS_OF_WORKER",
"TPTOTINC",
"ANY_RETIREMENT_ACCESS",
"PARTICIPATING",
"MATCHING", "MONTHCODE", "TJB1_JOBHRS1", "TOTYEARINC",
"TVAL_RET",
"TJB1_IND",
"RETIREMENT_ACCT_VAL",
"INDUSTRY_BROAD",
"INDUSTRY_DETAILED",
"TST_INTV")
# save file
setwd(output_path)
save(sipp_2023, file = "SIPP_2023_WRANGLED.RData")
# remove dependencies
rm(list = ls())
# load packages
library(dplyr)
library(survey)
library(batman)
library(ggplot2)
# set user path
project_directories <- list(
"sarah" = "/Users/sarah/Documents/GitHub/Retirement-Analysis-Urban-Rural"
)
current_user <- Sys.info()[["user"]]
if (!current_user %in% names(project_directories)) {
stop("Root folder for current user is not defined.")
}
# set project paths
project_path = project_directories[[current_user]]
data_path = file.path(project_path, "Data")
output_path = file.path(project_path, "Output")
# Read in wrangled SIPP data (see 1. wrangle SIPP 2023.R)
load(paste(output_path, "SIPP_2023_WRANGLED.RData", sep = "/"))
metro_ind_access = sipp_2023 %>% count(METRO_STATUS, INDUSTRY_BROAD,
ANY_RETIREMENT_ACCESS)  %>%
filter(METRO_STATUS != "Not identified") %>% filter(!is.na(METRO_STATUS))
# how many are under 30?
count(metro_ind_access %>% filter(n<30))
# how many industries proportionally?
count(metro_ind_access %>% filter(n<30))/count(metro_ind_access)
# if we exclude unreliable industries, what does this leave us with?
metro_ind_access_n30 = metro_ind_access %>% filter(n>=30)
incl =  unique(metro_ind_access_n30$INDUSTRY_BROAD)
# what do we exclude?
metro_ind_access_nu30 = metro_ind_access %>% filter(n<30)
unique(metro_ind_access_nu30$INDUSTRY_BROAD)
# if we exclude these industries, is variance too large?
sipp_2023_excl_ind = sipp_2023 %>%
filter(INDUSTRY_BROAD %in% incl) %>%
filter(METRO_STATUS != "Not identified")
# mean, se of retirement access generally.
svymean(~ANY_RETIREMENT_ACCESS_bool, design)
# means for sub groups
res = svyby(~ANY_RETIREMENT_ACCESS_bool, by = ~ METRO_STATUS + INDUSTRY_BROAD, design, svymean)
ggplot(res, aes(x = interaction(METRO_STATUS, INDUSTRY_BROAD), y = ANY_RETIREMENT_ACCESS_bool, fill = as.factor(METRO_STATUS))) +
geom_bar(stat = "identity", position = position_dodge(), color = "black") +
geom_errorbar(aes(ymin = ANY_RETIREMENT_ACCESS_bool - se, ymax = ANY_RETIREMENT_ACCESS_bool + se),
width = 0.2, position = position_dodge(0.9)) +
labs(title = "Retirement Access with Standard Errors",
x = "Industry & Metro",
y = "Retirement Access",
fill = "Metro Status") +
theme_minimal()
# if we exclude these industries, is variance too large?
sipp_2023_excl_ind = sipp_2023 %>%
filter(INDUSTRY_BROAD %in% incl) %>%
filter(METRO_STATUS != "Not identified")
design <- svydesign(ids = ~0, weights = ~WPFINWGT, data = sipp_2023_excl_ind)
# mean, se of retirement access generally.
svymean(~ANY_RETIREMENT_ACCESS_bool, design)
# means for sub groups
res = svyby(~ANY_RETIREMENT_ACCESS_bool, by = ~ METRO_STATUS + INDUSTRY_BROAD, design, svymean)
# remove dependencies
rm(list = ls())
# load packages
library(dplyr)
library(survey)
library(batman)
library(ggplot2)
# set user path
project_directories <- list(
"sarah" = "/Users/sarah/Documents/GitHub/Retirement-Analysis-Urban-Rural"
)
current_user <- Sys.info()[["user"]]
if (!current_user %in% names(project_directories)) {
stop("Root folder for current user is not defined.")
}
# set project paths
project_path = project_directories[[current_user]]
data_path = file.path(project_path, "Data")
output_path = file.path(project_path, "Output")
# Read in wrangled SIPP data (see 1. wrangle SIPP 2023.R)
load(paste(output_path, "SIPP_2023_WRANGLED.RData", sep = "/"))
# convert access, participation, and matching to bools
sipp_2023 = sipp_2023 %>%
mutate(ANY_RETIREMENT_ACCESS_bool = case_when(
ANY_RETIREMENT_ACCESS == "Yes" ~ 1,
ANY_RETIREMENT_ACCESS == "No" ~ 0
),
PARTICIPATING_bool = case_when(
PARTICIPATING == "Yes" ~ 1,
PARTICIPATING == "No" ~ 0
),
MATCHING_bool = case_when(
MATCHING == "Yes" ~ 1,
MATCHING == "No" ~ 0
))
metro_ind_access = sipp_2023 %>% count(METRO_STATUS, INDUSTRY_BROAD,
ANY_RETIREMENT_ACCESS)  %>%
filter(METRO_STATUS != "Not identified") %>% filter(!is.na(METRO_STATUS))
# how many are under 30?
count(metro_ind_access %>% filter(n<30))
# how many industries proportionally?
count(metro_ind_access %>% filter(n<30))/count(metro_ind_access)
# if we exclude unreliable industries, what does this leave us with?
metro_ind_access_n30 = metro_ind_access %>% filter(n>=30)
unique(metro_ind_access_n30$INDUSTRY_BROAD)
incl =  unique(metro_ind_access_n30$INDUSTRY_BROAD)
# what do we exclude?
metro_ind_access_nu30 = metro_ind_access %>% filter(n<30)
unique(metro_ind_access_nu30$INDUSTRY_BROAD)
# if we exclude these industries, is variance too large?
sipp_2023_excl_ind = sipp_2023 %>%
filter(INDUSTRY_BROAD %in% incl) %>%
filter(METRO_STATUS != "Not identified")
design <- svydesign(ids = ~0, weights = ~WPFINWGT, data = sipp_2023_excl_ind)
# mean, se of retirement access generally.
svymean(~ANY_RETIREMENT_ACCESS_bool, design)
# means for sub groups
res = svyby(~ANY_RETIREMENT_ACCESS_bool, by = ~ METRO_STATUS + INDUSTRY_BROAD, design, svymean)
ggplot(res, aes(x = interaction(METRO_STATUS, INDUSTRY_BROAD), y = ANY_RETIREMENT_ACCESS_bool, fill = as.factor(METRO_STATUS))) +
geom_bar(stat = "identity", position = position_dodge(), color = "black") +
geom_errorbar(aes(ymin = ANY_RETIREMENT_ACCESS_bool - se, ymax = ANY_RETIREMENT_ACCESS_bool + se),
width = 0.2, position = position_dodge(0.9)) +
labs(title = "Retirement Access with Standard Errors",
x = "Industry & Metro",
y = "Retirement Access",
fill = "Metro Status") +
theme_minimal()
svymean(~ANY_RETIREMENT_ACCESS_bool, design, deff = TRUE)
# all subgroups
res2 = svyby(~ANY_RETIREMENT_ACCESS_bool, by = ~METRO_STATUS + INDUSTRY_BROAD, design, svymean, deff = TRUE)
ggplot(res2, aes(x = interaction(METRO_STATUS, INDUSTRY_BROAD), y = DEff.ANY_RETIREMENT_ACCESS_bool, fill = as.factor(METRO_STATUS))) +
geom_bar(stat = "identity", position = position_dodge(), color = "black") +
labs(title = "Design Effect (DEFF) by Industry and Metro",
x = "Industry & Metro",
y = "Design Effect (DEFF)",
fill = "Metro Status") +
theme_minimal()
# issue with information workers. consider dropping these.
incl_v2 = Filter(function(x) x != "Information", incl)
res2 = res2 %>%
mutate(
lower_CI = ANY_RETIREMENT_ACCESS_bool - 1.96 * se,
upper_CI = ANY_RETIREMENT_ACCESS_bool + 1.96 * se
)
ggplot(res2, aes(x = interaction(METRO_STATUS, INDUSTRY_BROAD), y = ANY_RETIREMENT_ACCESS_bool, fill = as.factor(METRO_STATUS))) +
geom_bar(stat = "identity", position = position_dodge(), color = "black") +
geom_errorbar(aes(ymin = lower_CI, ymax = upper_CI),
width = 0.2, position = position_dodge(0.9)) +
labs(title = "Retirement access with 95% Confidence Intervals",
x = "Industry & Metro",
y = "Retirement access",
fill = "Metro Status") +
theme_minimal()
# confidence intervals for non-metro areas's information industry allow for estimates above 100% retirement access
confint(svymean(~ANY_RETIREMENT_ACCESS_bool, design))
print(incl_v2)
unique(sipp_2023$TST_INTV)
count(sipp_2023$TST_INTV)
# basic state count.
sipp_2023 %>%
count(TST_INTV)
# basic state count.
sipp_2023 %>%
count(TST_INTV)
sipp_2023 %>% count(METRO_STATUS, INDUSTRY_BROAD,
ANY_RETIREMENT_ACCESS)
# basic state count.
sipp_2023 %>%
count(TST_INTV)
# basic state count.
sipp_2023 %>%
count(TST_INTV) %<%
ggplot(aes(x = TST_INTV, y = n)) +
geom_bar(stat = "identity", position = "dodge", color = "black")
# basic state count.
sipp_2023 %>%
count(TST_INTV) %>%
ggplot(aes(x = TST_INTV, y = n)) +
geom_bar(stat = "identity", position = "dodge", color = "black")
ggplot(count_data, aes(x = industry, y = n, fill = as.factor(metro))) +
geom_bar(stat = "identity", position = "dodge")
# basic state count.
sipp_2023 %>%
count(TST_INTV) %>%
ggplot(aes(x = TST_INTV, y = n)) +
geom_bar(stat = "identity", position = "dodge", color = "black")
View(sipp_2023)
# basic state count.
sipp_2023 %>%
count(TST_INTV) %>%
ggplot(aes(x = TST_INTV, y = n)) +
geom_bar(stat = "identity", position = "dodge", color = "black") + theme_minimal()
sipp_2023 = sipp_2023 %>% left_join(state_fips_lookup, by = "TST_INTV" == "state_fips")
state_fips_lookup <- data.frame(
state_fips = c(1, 2, 4, 5, 6, 8, 9, 10, 11, 12, 13, 15, 16, 17, 18, 19,
20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33,
34, 35, 36, 37, 38, 39, 40, 41, 42, 44, 45, 46, 47, 48,
49, 50, 51, 53, 54, 55, 56),
state_abbr = c("AL", "AK", "AZ", "AR", "CA", "CO", "CT", "DE", "DC", "FL", "GA",
"HI", "ID", "IL", "IN", "IA", "KS", "KY", "LA", "ME", "MD", "MA",
"MI", "MN", "MS", "MO", "MT", "NE", "NV", "NH", "NJ", "NM", "NY",
"NC", "ND", "OH", "OK", "OR", "PA", "RI", "SC", "SD", "TN", "TX",
"UT", "VT", "VA", "WA", "WV", "WI", "WY")
)
sipp_2023 = sipp_2023 %>% left_join(state_fips_lookup, by = "TST_INTV" == "state_fips")
# basic state count.
sipp_2023 %>%
count(state_abbr) %>%
ggplot(aes(x = state_abbr, y = n)) +
geom_bar(stat = "identity", position = "dodge", color = "black") + theme_minimal()
names(sipp_2023)
sipp_2023 = sipp_2023 %>% left_join(state_fips_lookup, by = c("TST_INTV" == "state_fips"))
sipp_2023 = sipp_2023 %>% left_join(state_fips_lookup, by = c("TST_INTV" = "state_fips"))
names(sipp_2023)
# basic state count.
sipp_2023 %>%
count(state_abbr) %>%
ggplot(aes(x = state_abbr, y = n)) +
geom_bar(stat = "identity", position = "dodge", color = "black") + theme_minimal()
# basic state count.
sipp_2023 %>%
count(state_abbr) %>%
ggplot(aes(x = state_abbr, y = n)) +
geom_bar(stat = "identity", position = "dodge", color = "black") + theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# basic state count.
sipp_2023 %>%
count(state_abbr) %>%
ggplot(aes(x = state_abbr, y = n)) +
geom_bar(stat = "identity", position = "dodge", color = "black") + theme_minimal() +
theme(axis.text.x = element_text(angle = 90, hjust = 1))
filter(!is.na(METRO_STATUS)) %>% filter(METRO_STATUS != "Not identified") %>%
# basic state count.
sipp_2023 %>%
count(state_abbr, METRO_STATUS) %>%
filter(!is.na(METRO_STATUS)) %>% filter(METRO_STATUS != "Not identified") %>%
ggplot(aes(x = state_abbr, y = n, fill = as.factor(METRO_STATUS))) +
geom_bar(stat = "identity", position = "dodge", color = "black") + theme_minimal() +
theme(axis.text.x = element_text(angle = 90, hjust = 1))
# basic state count.
sipp_2023 %>%
count(state_abbr, METRO_STATUS) %>%
filter(!is.na(METRO_STATUS)) %>% filter(METRO_STATUS != "Not identified") %>%
ggplot(aes(x = state_abbr, y = n, fill = as.factor(METRO_STATUS))) +
geom_bar(stat = "identity", position = "dodge", color = "black") + theme_minimal() +
theme(axis.text.x = element_text(angle = 90, hjust = 1))
sipp_2023 %>%
count(state_abbr, METRO_STATUS) %>%
filter(!is.na(METRO_STATUS)) %>% filter(METRO_STATUS != "Not identified") %>%
filter(n<30) +
ggplot(aes(x = state_abbr, y = n, fill = as.factor(METRO_STATUS))) +
geom_bar(stat = "identity", position = "dodge", color = "black") + theme_minimal() +
theme(axis.text.x = element_text(angle = 90, hjust = 1))
sipp_2023 %>%
count(state_abbr, METRO_STATUS) %>%
filter(!is.na(METRO_STATUS)) %>% filter(METRO_STATUS != "Not identified") %>%
filter(n<30) %>%
ggplot(aes(x = state_abbr, y = n, fill = as.factor(METRO_STATUS))) +
geom_bar(stat = "identity", position = "dodge", color = "black") + theme_minimal() +
theme(axis.text.x = element_text(angle = 90, hjust = 1))
# basic state count.
sipp_2023 %>%
count(state_abbr, METRO_STATUS) %>%
filter(!is.na(METRO_STATUS)) %>% filter(METRO_STATUS != "Not identified") %>%
ggplot(aes(x = state_abbr, y = n, fill = as.factor(METRO_STATUS))) +
geom_bar(stat = "identity", position = "dodge", color = "black", width = 0.2) + theme_minimal() +
theme(axis.text.x = element_text(angle = 90, hjust = 1))
# basic state count.
sipp_2023 %>%
count(state_abbr, METRO_STATUS) %>%
filter(!is.na(METRO_STATUS)) %>% filter(METRO_STATUS != "Not identified") %>%
ggplot(aes(x = state_abbr, y = n, fill = as.factor(METRO_STATUS))) +
geom_bar(stat = "identity", position = "dodge", color = "black", width = 1) + theme_minimal() +
theme(axis.text.x = element_text(angle = 90, hjust = 1))
sipp_2023 %>%
count(state_abbr, METRO_STATUS) %>%
filter(!is.na(METRO_STATUS)) %>% filter(METRO_STATUS != "Not identified") %>%
filter(n<30) %>%
ggplot(aes(x = state_abbr, y = n, fill = as.factor(METRO_STATUS))) +
geom_bar(stat = "identity", position = "dodge", color = "black") + theme_minimal() +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
title("States X metro pairs with n < 30")
sipp_2023 %>%
count(state_abbr, METRO_STATUS) %>%
filter(!is.na(METRO_STATUS)) %>% filter(METRO_STATUS != "Not identified") %>%
filter(n<30) %>%
ggplot(aes(x = state_abbr, y = n, fill = as.factor(METRO_STATUS))) +
geom_bar(stat = "identity", position = "dodge", color = "black") + theme_minimal() +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
labs(title = "States X metro pairs with n < 30")
# basic state count.
sipp_2023 %>%
count(state_abbr, METRO_STATUS) %>%
filter(!is.na(METRO_STATUS)) %>% filter(METRO_STATUS != "Not identified") %>%
ggplot(aes(x = state_abbr, y = n, fill = as.factor(METRO_STATUS))) +
geom_bar(stat = "identity", position = "dodge", color = "black") + theme_minimal() +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
labs(title = "States X metro pairs unweighted count")
# basic state count.
sipp_2023 %>%
count(state_abbr, METRO_STATUS) %>%
filter(!is.na(METRO_STATUS)) %>% filter(METRO_STATUS != "Not identified") %>%
ggplot(aes(x = state_abbr, y = n, fill = as.factor(METRO_STATUS))) +
geom_bar(stat = "identity", position = "dodge", color = "black") + theme_minimal() +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
labs(title = "States X metro pairs unweighted count",
x = "State", y = "n")
# how many states
st_met_n_under30 = sipp_2023 %>%
count(state_abbr, METRO_STATUS) %>%
filter(!is.na(METRO_STATUS)) %>% filter(METRO_STATUS != "Not identified") %>%
filter(n<30)
unique(st_met_n_under30$state_abbr)
count(unique(st_met_n_under30$state_abbr))
length(unique(st_met_n_under30$state_abbr))
# how many states does this impact?
st_met_n_under30 = sipp_2023 %>%
count(state_abbr, METRO_STATUS) %>%
filter(!is.na(METRO_STATUS)) %>% filter(METRO_STATUS != "Not identified") %>%
filter(n<30)
length(unique(st_met_n_under30$state_abbr))
ggplot(res, aes(x = interaction(METRO_STATUS, INDUSTRY_BROAD), y = ANY_RETIREMENT_ACCESS_bool, fill = as.factor(METRO_STATUS))) +
geom_bar(stat = "identity", position = position_dodge(), color = "black") +
geom_errorbar(aes(ymin = ANY_RETIREMENT_ACCESS_bool - se, ymax = ANY_RETIREMENT_ACCESS_bool + se),
width = 0.2, position = position_dodge(0.9)) +
labs(title = "Retirement Access with Standard Errors",
x = "Industry & Metro",
y = "Retirement Access",
fill = "Metro Status",
axis.ticks.x  = element_blank()) +
theme_minimal()
ggplot(res, aes(x = interaction(METRO_STATUS, INDUSTRY_BROAD), y = ANY_RETIREMENT_ACCESS_bool, fill = as.factor(METRO_STATUS))) +
geom_bar(stat = "identity", position = position_dodge(), color = "black") +
geom_errorbar(aes(ymin = ANY_RETIREMENT_ACCESS_bool - se, ymax = ANY_RETIREMENT_ACCESS_bool + se),
width = 0.2, position = position_dodge(0.9)) +
labs(title = "Retirement Access with Standard Errors",
x = "Industry & Metro",
y = "Retirement Access",
fill = "Metro Status",
axis.ticks.x  = element_blank()) +
theme_minimal()
incl_v2
incl_v2
11/(11+8)
